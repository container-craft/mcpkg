/* SPDX-License-Identifier: MIT */
/*
 * Auto-generated by mpgen â€” DO NOT EDIT BY HAND.
 * Source schema: /home/jmills/git/opensource/mcpkg/mpgen/schemas/ledger/ledger_attestation.yaml
 */

#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdarg.h>

#include "mp/mcpkg_mp_ledger_attestation.h"

#include "mp/mcpkg_mp_util.h"
#include "container/mcpkg_list.h"
#include "container/mcpkg_str_list.h"

/* If we reference nested structs, pull in their generated headers. */



MCPKG_API struct McPkgAttestation *mcpkg_mp_ledger_attestation_new(void)
{
	struct McPkgAttestation *p;

	p = calloc(1, sizeof(*p));
	return p;
}

MCPKG_API void mcpkg_mp_ledger_attestation_free(struct McPkgAttestation *p)
{
	if (!p)
		return;

	/* free pkg_id */
	free(p->pkg_id);
	p->pkg_id = NULL;

	/* free version */
	free(p->version);
	p->version = NULL;

	/* free manifest_sha256 */
	/* free signer_pub */
	/* free signature */
	/* free ts_ms */

	free(p);
}

MCPKG_API char *mcpkg_mp_ledger_attestation_debug_str(const struct
                McPkgAttestation *p)
{
	char *s = NULL;
	size_t cap = 0, len = 0;

	if (!p)
		return mcpkg_mp_util_dup_str("McPkgAttestation(null)");

	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "McPkgAttestation{") < 0)
		goto oom;

	/* pkg_id */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             " pkg_id=%s,",
	                             p->pkg_id ? p->pkg_id : "NULL") < 0)
		goto oom;

	/* version */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "version=%s,",
	                             p->version ? p->version : "NULL") < 0)
		goto oom;

	/* manifest_sha256 */
	{
		size_t i_;

		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "manifest_sha256=0x") < 0)
			goto oom;
		for (i_ = 0; i_ < 32; i_++) {
			if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "%02x",
			                             (unsigned int)p->manifest_sha256[i_]) < 0)
				goto oom;
		}
		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, ",") < 0)
			goto oom;
	}

	/* signer_pub */
	{
		size_t i_;

		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "signer_pub=0x") < 0)
			goto oom;
		for (i_ = 0; i_ < 32; i_++) {
			if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "%02x",
			                             (unsigned int)p->signer_pub[i_]) < 0)
				goto oom;
		}
		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, ",") < 0)
			goto oom;
	}

	/* signature */
	{
		size_t i_;

		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "signature=0x") < 0)
			goto oom;
		for (i_ = 0; i_ < 64; i_++) {
			if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "%02x",
			                             (unsigned int)p->signature[i_]) < 0)
				goto oom;
		}
		if (mcpkg_mp_util_dbg_append(&s, &cap, &len, ",") < 0)
			goto oom;
	}

	/* ts_ms */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "ts_ms=%lld,",
	                             (long long)p->ts_ms) < 0)
		goto oom;


	if (len > 0 && s[len - 1] == ',')
		s[len - 1] = '}';
	else
		(void)mcpkg_mp_util_dbg_append(&s, &cap, &len, "}");

	return s;
oom:
	free(s);
	return NULL;
}



MCPKG_API int mcpkg_mp_ledger_attestation_pack(const struct McPkgAttestation *p,
                void **out_buf, size_t *out_len)
{
	struct McPkgMpWriter w;
	int mpret;

	if (!p || !out_buf || !out_len)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_writer_init(&w);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	/* header(2) + all fields (pack nil for missing optionals) */
	mpret = mcpkg_mp_map_begin(&w, 8);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	mpret = mcpkg_mp_write_header(&w, "ledger.attestation", 1);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* pkg_id */
	if (p->pkg_id)
		mpret = mcpkg_mp_kv_str(&w, 2, p->pkg_id);
	else
		mpret = mcpkg_mp_kv_nil(&w, 2);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* version */
	if (p->version)
		mpret = mcpkg_mp_kv_str(&w, 3, p->version);
	else
		mpret = mcpkg_mp_kv_nil(&w, 3);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* manifest_sha256 */
	mpret = mcpkg_mp_kv_bin(&w, 4, p->manifest_sha256, 32);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* signer_pub */
	mpret = mcpkg_mp_kv_bin(&w, 5, p->signer_pub, 32);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* signature */
	mpret = mcpkg_mp_kv_bin(&w, 6, p->signature, 64);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* ts_ms */
	mpret = mcpkg_mp_kv_i64(&w, 7, p->ts_ms);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;


	mpret = mcpkg_mp_writer_finish(&w, out_buf, out_len);
out_w:
	mcpkg_mp_writer_destroy(&w);
	return mpret;
}


MCPKG_API int mcpkg_mp_ledger_attestation_unpack(const void *buf, size_t len,
                struct McPkgAttestation **out_p)
{
	struct McPkgMpReader r;
	struct McPkgAttestation *p = NULL;
	int mpret, ver = 0;

	if (!buf || !len || !out_p)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_reader_init(&r, buf, len);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	mpret = mcpkg_mp_expect_tag(&r, "ledger.attestation", &ver);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_r;

	p = mcpkg_mp_ledger_attestation_new();
	if (!p) {
		mpret = MCPKG_MP_ERR_NO_MEMORY;
		goto out_r;
	}

	/* pkg_id */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 2, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->pkg_id = malloc(pl_ + 1);
			if (!p->pkg_id) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->pkg_id, ptr_, pl_);
			p->pkg_id[pl_] = '\0';
		}
		if (!found_ || !p->pkg_id) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}

	/* version */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 3, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->version = malloc(pl_ + 1);
			if (!p->version) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->version, ptr_, pl_);
			p->version[pl_] = '\0';
		}
		if (!found_ || !p->version) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}

	/* manifest_sha256 */
	{
		const void *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_bin_borrow(&r, 4, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (!found_ || pl_ != 32) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}

		if (found_ && ptr_ && pl_ == 32)
			memcpy(p->manifest_sha256, ptr_, 32);
	}

	/* signer_pub */
	{
		const void *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_bin_borrow(&r, 5, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (!found_ || pl_ != 32) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}

		if (found_ && ptr_ && pl_ == 32)
			memcpy(p->signer_pub, ptr_, 32);
	}

	/* signature */
	{
		const void *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_bin_borrow(&r, 6, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (!found_ || pl_ != 64) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}

		if (found_ && ptr_ && pl_ == 64)
			memcpy(p->signature, ptr_, 64);
	}

	/* ts_ms */
	{
		uint64_t val_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_u64(&r, 7, &val_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_)
			p->ts_ms = (int64_t)val_;
		if (!found_) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}


	*out_p = p;
	mcpkg_mp_reader_destroy(&r);
	return MCPKG_MP_NO_ERROR;

out_err:
	mcpkg_mp_ledger_attestation_free(p);
out_r:
	mcpkg_mp_reader_destroy(&r);
	return mpret;
}
