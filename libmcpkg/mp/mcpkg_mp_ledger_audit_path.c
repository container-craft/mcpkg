/* SPDX-License-Identifier: MIT */
/*
 * Auto-generated by mpgen â€” DO NOT EDIT BY HAND.
 * Source schema: /home/jmills/git/opensource/mcpkg/mpgen/schemas/ledger/ledger_audit_path.yaml
 */

#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdarg.h>

#include "mp/mcpkg_mp_ledger_audit_path.h"

#include "mp/mcpkg_mp_util.h"
#include "container/mcpkg_list.h"
#include "container/mcpkg_str_list.h"

/* If we reference nested structs, pull in their generated headers. */
#include "mp/mcpkg_mp_ledger_audit_node.h"



MCPKG_API struct McPkgAuditPath *mcpkg_mp_ledger_audit_path_new(void)
{
	struct McPkgAuditPath *p;

	p = calloc(1, sizeof(*p));
	return p;
}

MCPKG_API void mcpkg_mp_ledger_audit_path_free(struct McPkgAuditPath *p)
{
	if (!p)
		return;

	/* free nodes */
	if (p->nodes) {
		size_t i_, n_ = mcpkg_list_size(p->nodes);
		for (i_ = 0; i_ < n_; i_++) {
			struct McPkgAuditNode *elt_ = NULL;

			if (mcpkg_list_at(p->nodes, i_, &elt_) == MCPKG_CONTAINER_OK && elt_)
				mcpkg_mp_ledger_audit_node_free(elt_);  // FIXME no header access
		}
		mcpkg_list_free(p->nodes);
		p->nodes = NULL;
	}


	free(p);
}

MCPKG_API char *mcpkg_mp_ledger_audit_path_debug_str(const struct McPkgAuditPath
                *p)
{
	char *s = NULL;
	size_t cap = 0, len = 0;

	if (!p)
		return mcpkg_mp_util_dup_str("McPkgAuditPath(null)");

	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "McPkgAuditPath{") < 0)
		goto oom;

	/* nodes */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "nodes=[%zu],",
	                             p->nodes ? mcpkg_list_size(p->nodes) : 0ul) < 0)
		goto oom;


	if (len > 0 && s[len - 1] == ',')
		s[len - 1] = '}';
	else
		(void)mcpkg_mp_util_dbg_append(&s, &cap, &len, "}");

	return s;
oom:
	free(s);
	return NULL;
}



MCPKG_API int mcpkg_mp_ledger_audit_path_pack(const struct McPkgAuditPath *p,
                void **out_buf, size_t *out_len)
{
	struct McPkgMpWriter w;
	int mpret;

	if (!p || !out_buf || !out_len)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_writer_init(&w);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	/* header(2) + all fields (pack nil for missing optionals) */
	mpret = mcpkg_mp_map_begin(&w, 3);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	mpret = mcpkg_mp_write_header(&w, "ledger.audit_path", 1);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* nodes */
	{
		size_t i_, n_ = p->nodes ? mcpkg_list_size(p->nodes) : 0;

		mpret = mcpkg_mp_kv_array_begin(&w, 2, (uint32_t)n_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;

		for (i_ = 0; i_ < n_; i_++) {
			struct McPkgAuditNode *elt_ = NULL;
			void *b_ = NULL;
			size_t bl_ = 0;

			if (mcpkg_list_at(p->nodes, i_, &elt_) != MCPKG_CONTAINER_OK || !elt_) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_w;
			}
			if (mcpkg_mp_ledger_audit_node_pack(elt_, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_w;
			}
			mpret = mcpkg_mp_write_bin(&w, b_, (uint32_t)bl_);
			free(b_);
			if (mpret != MCPKG_MP_NO_ERROR)
				goto out_w;
		}
	}


	mpret = mcpkg_mp_writer_finish(&w, out_buf, out_len);
out_w:
	mcpkg_mp_writer_destroy(&w);
	return mpret;
}


MCPKG_API int mcpkg_mp_ledger_audit_path_unpack(const void *buf, size_t len,
                struct McPkgAuditPath **out_p)
{
	struct McPkgMpReader r;
	struct McPkgAuditPath *p = NULL;
	int mpret, ver = 0;

	if (!buf || !len || !out_p)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_reader_init(&r, buf, len);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	mpret = mcpkg_mp_expect_tag(&r, "ledger.audit_path", &ver);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_r;

	p = mcpkg_mp_ledger_audit_path_new();
	if (!p) {
		mpret = MCPKG_MP_ERR_NO_MEMORY;
		goto out_r;
	}

	/* nodes */
	{
		struct McPkgMpArrayCur *cur_ = NULL;
		size_t n_ = 0;
		size_t i_;
		int found_ = 0;

		mpret = mcpkg_mp_get_array_cur(&r, 2, &cur_, &n_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;


		if (found_ && n_ > 0) {
			/// yikes
			p->nodes = mcpkg_list_new(sizeof(struct McPkgAuditNode *), NULL, 0, 0);
			if (!p->nodes) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				mcpkg_mp_array_cur_destroy(cur_);
				goto out_err;
			}
			for (i_ = 0; i_ < n_; i_++) {
				const void *ptr_ = NULL;
				size_t pl_ = 0;
				struct McPkgAuditNode *elt_ = NULL;

				if (mcpkg_mp_array_get_bin_borrow(cur_, i_, &ptr_, &pl_) != MCPKG_MP_NO_ERROR) {
					mcpkg_mp_array_cur_destroy(cur_);
					goto out_err;
				}
				if (mcpkg_mp_ledger_audit_node_unpack(ptr_, pl_, &elt_) != MCPKG_MP_NO_ERROR) {
					mcpkg_mp_array_cur_destroy(cur_);
					mpret = MCPKG_MP_ERR_PARSE;
					goto out_err;
				}
				if (mcpkg_list_push(p->nodes, &elt_) != MCPKG_CONTAINER_OK) {
					mcpkg_mp_ledger_audit_node_free(elt_);
					mcpkg_mp_array_cur_destroy(cur_);
					mpret = MCPKG_MP_ERR_NO_MEMORY;
					goto out_err;
				}
			}
		}

		if (cur_)
			mcpkg_mp_array_cur_destroy(cur_);
	}


	*out_p = p;
	mcpkg_mp_reader_destroy(&r);
	return MCPKG_MP_NO_ERROR;

out_err:
	mcpkg_mp_ledger_audit_path_free(p);
out_r:
	mcpkg_mp_reader_destroy(&r);
	return mpret;
}
