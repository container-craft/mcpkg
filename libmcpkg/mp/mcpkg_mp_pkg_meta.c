/* SPDX-License-Identifier: MIT */
/*
 * Auto-generated by mpgen â€” DO NOT EDIT BY HAND.
 * Source schema: /home/jmills/git/opensource/mcpkg/mpgen/schemas/pkg/pkg_meta.yaml
 */

#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdarg.h>

#include "mp/mcpkg_mp_pkg_meta.h"

#include "mp/mcpkg_mp_util.h"
#include "container/mcpkg_list.h"
#include "container/mcpkg_str_list.h"

/* If we reference nested structs, pull in their generated headers. */
#include "mp/mcpkg_mp_pkg_depends.h"
#include "mp/mcpkg_mp_pkg_file.h"
#include "mp/mcpkg_mp_pkg_origin.h"



MCPKG_API struct McPkgCache *mcpkg_mp_pkg_meta_new(void)
{
	struct McPkgCache *p;

	p = calloc(1, sizeof(*p));
	return p;
}

MCPKG_API void mcpkg_mp_pkg_meta_free(struct McPkgCache *p)
{
	if (!p)
		return;

	/* free id */
	free(p->id);
	p->id = NULL;

	/* free slug */
	free(p->slug);
	p->slug = NULL;

	/* free version */
	free(p->version);
	p->version = NULL;

	/* free title */
	free(p->title);
	p->title = NULL;

	/* free description */
	free(p->description);
	p->description = NULL;

	/* free license_id */
	free(p->license_id);
	p->license_id = NULL;

	/* free home_page */
	free(p->home_page);
	p->home_page = NULL;

	/* free source_repo */
	free(p->source_repo);
	p->source_repo = NULL;

	/* free loaders */
	if (p->loaders) {
		mcpkg_stringlist_free(p->loaders);
		p->loaders = NULL;
	}

	/* free sections */
	if (p->sections) {
		mcpkg_stringlist_free(p->sections);
		p->sections = NULL;
	}

	/* free configs */
	if (p->configs) {
		mcpkg_stringlist_free(p->configs);
		p->configs = NULL;
	}

	/* free depends */
	if (p->depends) {
		size_t i_, n_ = mcpkg_list_size(p->depends);
		for (i_ = 0; i_ < n_; i_++) {
			struct McPkgDepends *elt_ = NULL;

			if (mcpkg_list_at(p->depends, i_, &elt_) == MCPKG_CONTAINER_OK && elt_)
				mcpkg_mp_pkg_depends_free(elt_);  // FIXME no header access
		}
		mcpkg_list_free(p->depends);
		p->depends = NULL;
	}

	/* free file */
	if (p->file) {
		mcpkg_mp_pkg_file_free(p->file);
		p->file = NULL;
	}

	/* free client */
	/* free server */
	/* free origin */
	if (p->origin) {
		mcpkg_mp_pkg_origin_free(p->origin);
		p->origin = NULL;
	}

	/* free flags */
	/* free schema */

	free(p);
}

MCPKG_API char *mcpkg_mp_pkg_meta_debug_str(const struct McPkgCache *p)
{
	char *s = NULL;
	size_t cap = 0, len = 0;

	if (!p)
		return mcpkg_mp_util_dup_str("McPkgCache(null)");

	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "McPkgCache{") < 0)
		goto oom;

	/* id */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             " id=%s,",
	                             p->id ? p->id : "NULL") < 0)
		goto oom;

	/* slug */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "slug=%s,",
	                             p->slug ? p->slug : "NULL") < 0)
		goto oom;

	/* version */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "version=%s,",
	                             p->version ? p->version : "NULL") < 0)
		goto oom;

	/* title */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "title=%s,",
	                             p->title ? p->title : "NULL") < 0)
		goto oom;

	/* description */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "description=%s,",
	                             p->description ? p->description : "NULL") < 0)
		goto oom;

	/* license_id */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "license_id=%s,",
	                             p->license_id ? p->license_id : "NULL") < 0)
		goto oom;

	/* home_page */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "home_page=%s,",
	                             p->home_page ? p->home_page : "NULL") < 0)
		goto oom;

	/* source_repo */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
	                             "source_repo=%s,",
	                             p->source_repo ? p->source_repo : "NULL") < 0)
		goto oom;

	/* loaders */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "loaders=[%zu],",
	                             p->loaders ? mcpkg_stringlist_size(p->loaders) : 0ul) < 0)
		goto oom;

	/* sections */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "sections=[%zu],",
	                             p->sections ? mcpkg_stringlist_size(p->sections) : 0ul) < 0)
		goto oom;

	/* configs */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "configs=[%zu],",
	                             p->configs ? mcpkg_stringlist_size(p->configs) : 0ul) < 0)
		goto oom;

	/* depends */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "depends=[%zu],",
	                             p->depends ? mcpkg_list_size(p->depends) : 0ul) < 0)
		goto oom;

	/* file */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "file=%s,",
	                             p->file ? "set" : "NULL") < 0)
		goto oom;

	/* client */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "client=%d,",
	                             (int)p->client) < 0)
		goto oom;

	/* server */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "server=%d,",
	                             (int)p->server) < 0)
		goto oom;

	/* origin */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "origin=%s,",
	                             p->origin ? "set" : "NULL") < 0)
		goto oom;

	/* flags */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "flags=%u,",
	                             (unsigned int)p->flags) < 0)
		goto oom;

	/* schema */
	if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "schema=%u,",
	                             (unsigned int)p->schema) < 0)
		goto oom;


	if (len > 0 && s[len - 1] == ',')
		s[len - 1] = '}';
	else
		(void)mcpkg_mp_util_dbg_append(&s, &cap, &len, "}");

	return s;
oom:
	free(s);
	return NULL;
}



MCPKG_API int mcpkg_mp_pkg_meta_pack(const struct McPkgCache *p,
                                     void **out_buf, size_t *out_len)
{
	struct McPkgMpWriter w;
	int mpret;

	if (!p || !out_buf || !out_len)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_writer_init(&w);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	/* header(2) + all fields (pack nil for missing optionals) */
	mpret = mcpkg_mp_map_begin(&w, 20);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	mpret = mcpkg_mp_write_header(&w, "pkg.meta", 1);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* id */
	if (p->id)
		mpret = mcpkg_mp_kv_str(&w, 2, p->id);
	else
		mpret = mcpkg_mp_kv_nil(&w, 2);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* slug */
	if (p->slug)
		mpret = mcpkg_mp_kv_str(&w, 3, p->slug);
	else
		mpret = mcpkg_mp_kv_nil(&w, 3);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* version */
	if (p->version)
		mpret = mcpkg_mp_kv_str(&w, 4, p->version);
	else
		mpret = mcpkg_mp_kv_nil(&w, 4);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* title */
	if (p->title)
		mpret = mcpkg_mp_kv_str(&w, 5, p->title);
	else
		mpret = mcpkg_mp_kv_nil(&w, 5);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* description */
	if (p->description)
		mpret = mcpkg_mp_kv_str(&w, 6, p->description);
	else
		mpret = mcpkg_mp_kv_nil(&w, 6);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* license_id */
	if (p->license_id)
		mpret = mcpkg_mp_kv_str(&w, 7, p->license_id);
	else
		mpret = mcpkg_mp_kv_nil(&w, 7);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* home_page */
	if (p->home_page)
		mpret = mcpkg_mp_kv_str(&w, 8, p->home_page);
	else
		mpret = mcpkg_mp_kv_nil(&w, 8);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* source_repo */
	if (p->source_repo)
		mpret = mcpkg_mp_kv_str(&w, 9, p->source_repo);
	else
		mpret = mcpkg_mp_kv_nil(&w, 9);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* loaders */
	mpret = mcpkg_mp_kv_strlist(&w, 10, p->loaders);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* sections */
	mpret = mcpkg_mp_kv_strlist(&w, 11, p->sections);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* configs */
	mpret = mcpkg_mp_kv_strlist(&w, 12, p->configs);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* depends */
	{
		size_t i_, n_ = p->depends ? mcpkg_list_size(p->depends) : 0;

		mpret = mcpkg_mp_kv_array_begin(&w, 13, (uint32_t)n_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;

		for (i_ = 0; i_ < n_; i_++) {
			struct McPkgDepends *elt_ = NULL;
			void *b_ = NULL;
			size_t bl_ = 0;

			if (mcpkg_list_at(p->depends, i_, &elt_) != MCPKG_CONTAINER_OK || !elt_) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_w;
			}
			if (mcpkg_mp_pkg_depends_pack(elt_, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_w;
			}
			mpret = mcpkg_mp_write_bin(&w, b_, (uint32_t)bl_);
			free(b_);
			if (mpret != MCPKG_MP_NO_ERROR)
				goto out_w;
		}
	}

	/* file */
	if (p->file) {
		void *b_ = NULL;
		size_t bl_ = 0;

		if (mcpkg_mp_pkg_file_pack(p->file, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_w;
		}
		mpret = mcpkg_mp_kv_bin(&w, 14, b_, (uint32_t)bl_);
		free(b_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;
	} else {
		mpret = mcpkg_mp_kv_nil(&w, 14);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;
	}

	/* client */
	mpret = mcpkg_mp_kv_i32(&w, 15, p->client);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* server */
	mpret = mcpkg_mp_kv_i32(&w, 16, p->server);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* origin */
	if (p->origin) {
		void *b_ = NULL;
		size_t bl_ = 0;

		if (mcpkg_mp_pkg_origin_pack(p->origin, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_w;
		}
		mpret = mcpkg_mp_kv_bin(&w, 17, b_, (uint32_t)bl_);
		free(b_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;
	} else {
		mpret = mcpkg_mp_kv_nil(&w, 17);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_w;
	}

	/* flags */
	mpret = mcpkg_mp_kv_u32(&w, 18, p->flags);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;

	/* schema */
	mpret = mcpkg_mp_kv_u32(&w, 19, p->schema);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_w;


	mpret = mcpkg_mp_writer_finish(&w, out_buf, out_len);
out_w:
	mcpkg_mp_writer_destroy(&w);
	return mpret;
}


MCPKG_API int mcpkg_mp_pkg_meta_unpack(const void *buf, size_t len,
                                       struct McPkgCache **out_p)
{
	struct McPkgMpReader r;
	struct McPkgCache *p = NULL;
	int mpret, ver = 0;

	if (!buf || !len || !out_p)
		return MCPKG_MP_ERR_INVALID_ARG;

	mpret = mcpkg_mp_reader_init(&r, buf, len);
	if (mpret != MCPKG_MP_NO_ERROR)
		return mpret;

	mpret = mcpkg_mp_expect_tag(&r, "pkg.meta", &ver);
	if (mpret != MCPKG_MP_NO_ERROR)
		goto out_r;

	p = mcpkg_mp_pkg_meta_new();
	if (!p) {
		mpret = MCPKG_MP_ERR_NO_MEMORY;
		goto out_r;
	}

	/* id */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 2, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->id = malloc(pl_ + 1);
			if (!p->id) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->id, ptr_, pl_);
			p->id[pl_] = '\0';
		}
		if (!found_ || !p->id) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}

	/* slug */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 3, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->slug = malloc(pl_ + 1);
			if (!p->slug) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->slug, ptr_, pl_);
			p->slug[pl_] = '\0';
		}
	}

	/* version */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 4, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->version = malloc(pl_ + 1);
			if (!p->version) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->version, ptr_, pl_);
			p->version[pl_] = '\0';
		}
		if (!found_ || !p->version) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}

	/* title */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 5, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->title = malloc(pl_ + 1);
			if (!p->title) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->title, ptr_, pl_);
			p->title[pl_] = '\0';
		}
	}

	/* description */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 6, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->description = malloc(pl_ + 1);
			if (!p->description) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->description, ptr_, pl_);
			p->description[pl_] = '\0';
		}
	}

	/* license_id */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 7, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->license_id = malloc(pl_ + 1);
			if (!p->license_id) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->license_id, ptr_, pl_);
			p->license_id[pl_] = '\0';
		}
	}

	/* home_page */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 8, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->home_page = malloc(pl_ + 1);
			if (!p->home_page) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->home_page, ptr_, pl_);
			p->home_page[pl_] = '\0';
		}
	}

	/* source_repo */
	{
		const char *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_str_borrow(&r, 9, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_ && ptr_) {
			p->source_repo = malloc(pl_ + 1);
			if (!p->source_repo) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				goto out_err;
			}
			memcpy(p->source_repo, ptr_, pl_);
			p->source_repo[pl_] = '\0';
		}
	}

	/* loaders */
	{
		struct McPkgStringList *sl_ = NULL;

		mpret = mcpkg_mp_get_strlist_dup(&r, 10, &sl_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		p->loaders = sl_;
		if (!p->loaders) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}
	}

	/* sections */
	{
		struct McPkgStringList *sl_ = NULL;

		mpret = mcpkg_mp_get_strlist_dup(&r, 11, &sl_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		p->sections = sl_;
	}

	/* configs */
	{
		struct McPkgStringList *sl_ = NULL;

		mpret = mcpkg_mp_get_strlist_dup(&r, 12, &sl_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		p->configs = sl_;
	}

	/* depends */
	{
		struct McPkgMpArrayCur *cur_ = NULL;
		size_t n_ = 0;
		size_t i_;
		int found_ = 0;

		mpret = mcpkg_mp_get_array_cur(&r, 13, &cur_, &n_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;


		if (found_ && n_ > 0) {
			/// yikes
			p->depends = mcpkg_list_new(sizeof(struct McPkgDepends *), NULL, 0, 0);
			if (!p->depends) {
				mpret = MCPKG_MP_ERR_NO_MEMORY;
				mcpkg_mp_array_cur_destroy(cur_);
				goto out_err;
			}
			for (i_ = 0; i_ < n_; i_++) {
				const void *ptr_ = NULL;
				size_t pl_ = 0;
				struct McPkgDepends *elt_ = NULL;

				if (mcpkg_mp_array_get_bin_borrow(cur_, i_, &ptr_, &pl_) != MCPKG_MP_NO_ERROR) {
					mcpkg_mp_array_cur_destroy(cur_);
					goto out_err;
				}
				if (mcpkg_mp_pkg_depends_unpack(ptr_, pl_, &elt_) != MCPKG_MP_NO_ERROR) {
					mcpkg_mp_array_cur_destroy(cur_);
					mpret = MCPKG_MP_ERR_PARSE;
					goto out_err;
				}
				if (mcpkg_list_push(p->depends, &elt_) != MCPKG_CONTAINER_OK) {
					mcpkg_mp_pkg_depends_free(elt_);
					mcpkg_mp_array_cur_destroy(cur_);
					mpret = MCPKG_MP_ERR_NO_MEMORY;
					goto out_err;
				}
			}
		}

		if (cur_)
			mcpkg_mp_array_cur_destroy(cur_);
	}

	/* file */
	{
		const void *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_bin_borrow(&r, 14, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (!found_ || !ptr_ || pl_ == 0) {
			mpret = MCPKG_MP_ERR_PARSE;
			goto out_err;
		}

		if (found_ && ptr_ && pl_ > 0) {
			if (mcpkg_mp_pkg_file_unpack(ptr_, pl_, &p->file) != MCPKG_MP_NO_ERROR) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_err;
			}
		}
	}

	/* client */
	{
		uint32_t val_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_u32(&r, 15, &val_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_)
			p->client = (int32_t)val_;
	}

	/* server */
	{
		uint32_t val_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_u32(&r, 16, &val_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_)
			p->server = (int32_t)val_;
	}

	/* origin */
	{
		const void *ptr_ = NULL;
		size_t pl_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_bin_borrow(&r, 17, &ptr_, &pl_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;


		if (found_ && ptr_ && pl_ > 0) {
			if (mcpkg_mp_pkg_origin_unpack(ptr_, pl_, &p->origin) != MCPKG_MP_NO_ERROR) {
				mpret = MCPKG_MP_ERR_PARSE;
				goto out_err;
			}
		}
	}

	/* flags */
	{
		uint32_t val_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_u32(&r, 18, &val_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_)
			p->flags = (int32_t)val_;
	}

	/* schema */
	{
		uint32_t val_ = 0;
		int found_ = 0;

		mpret = mcpkg_mp_get_u32(&r, 19, &val_, &found_);
		if (mpret != MCPKG_MP_NO_ERROR)
			goto out_err;

		if (found_)
			p->schema = (int32_t)val_;
	}


	*out_p = p;
	mcpkg_mp_reader_destroy(&r);
	return MCPKG_MP_NO_ERROR;

out_err:
	mcpkg_mp_pkg_meta_free(p);
out_r:
	mcpkg_mp_reader_destroy(&r);
	return mpret;
}
