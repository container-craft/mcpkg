/* SPDX-License-Identifier: MIT */
/*
 * Auto-generated by mpgen â€” DO NOT EDIT BY HAND.
 * Source schema: {{ sch.schema_path if sch.schema_path is defined else (sch.unit ~ "/" ~ sch.base) }}
 */

#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdarg.h>

#include "{{ sch.include_prefix }}/mcpkg_mp_{{ sch.out_base }}.h"

#include "mp/mcpkg_mp_util.h"
#include "container/mcpkg_list.h"
#include "container/mcpkg_str_list.h"

/* If we reference nested structs, pull in their generated headers. */
{% set ref_structs = (sch.fields | selectattr('kind','in',['STRUCT','LIST_STRUCT']) | map(attribute='ref_sym') | unique | list) %}
{% for r in ref_structs %}
#include "{{ sch.include_prefix }}/mcpkg_mp_{{ r }}.h"
{% endfor %}

{% set sym_prefix = "mcpkg_mp_" ~ sch.out_base %}


MCPKG_API struct {{ sch.c_struct }} *{{ sym_prefix }}_new(void)
{
    struct {{ sch.c_struct }} *p;

    p = calloc(1, sizeof(*p));
    return p;
}

MCPKG_API void {{ sym_prefix }}_free(struct {{ sch.c_struct }} *p)
{
    if (!p)
        return;

    {% for f in sch.fields %}
    /* free {{ f.name }} */
    {% if f.kind == 'SCALAR' and f.type == 'str' %}
    free(p->{{ f.name }});
    p->{{ f.name }} = NULL;

    {% elif f.kind == 'LIST_SCALAR' %}
    if (p->{{ f.name }}) {
        mcpkg_stringlist_free(p->{{ f.name }});
        p->{{ f.name }} = NULL;
    }

    {% elif f.kind == 'STRUCT' %}
    if (p->{{ f.name }}) {
        mcpkg_mp_{{ f.ref_sym }}_free(p->{{ f.name }});
        p->{{ f.name }} = NULL;
    }

    {% elif f.kind == 'LIST_STRUCT' %}
    if (p->{{ f.name }}) {
        size_t i_, n_ = mcpkg_list_size(p->{{ f.name }});
        for (i_ = 0; i_ < n_; i_++) {
            struct {{ f.ctype }} *elt_ = NULL;

            if (mcpkg_list_at(p->{{ f.name }}, i_, &elt_) == MCPKG_CONTAINER_OK && elt_)
                mcpkg_mp_{{ f.ref_sym }}_free(elt_);  // FIXME no header access
        }
        mcpkg_list_free(p->{{ f.name }});
        p->{{ f.name }} = NULL;
    }

    {% elif f.kind == 'LIST_BIN' %}
    if (p->{{ f.name }}) {
        mcpkg_list_free(p->{{ f.name }});
        p->{{ f.name }} = NULL;
    }

    {% endif %}
    {% endfor %}

    free(p);
}

MCPKG_API char *{{ sym_prefix }}_debug_str(const struct {{ sch.c_struct }} *p)
{
    char *s = NULL;
    size_t cap = 0, len = 0;

    if (!p)
        return mcpkg_mp_util_dup_str("{{ sch.c_struct }}(null)");

    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ sch.c_struct }}{") < 0)
        goto oom;

    {% for f in sch.fields %}
    /* {{ f.name }} */
    {% if f.kind == 'SCALAR' and f.type == 'str' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len,
                     "{{ ' ' if loop.first else '' }}{{ f.name }}=%s,",
                     p->{{ f.name }} ? p->{{ f.name }} : "NULL") < 0)
        goto oom;

    {% elif f.kind == 'SCALAR' and f.type == 'i32' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=%d,",
                     (int)p->{{ f.name }}) < 0)
        goto oom;

    {% elif f.kind == 'SCALAR' and f.type == 'u32' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=%u,",
                     (unsigned int)p->{{ f.name }}) < 0)
        goto oom;

    {% elif f.kind == 'SCALAR' and f.type == 'i64' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=%lld,",
                     (long long)p->{{ f.name }}) < 0)
        goto oom;

    {% elif f.kind == 'SCALAR' and f.type == 'u64' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=%llu,",
                     (unsigned long long)p->{{ f.name }}) < 0)
        goto oom;

    {% elif f.kind == 'BIN' %}
    {
        size_t i_;

        if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=0x") < 0)
            goto oom;
        for (i_ = 0; i_ < {{ f.size }}; i_++) {
            if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "%02x",
                             (unsigned int)p->{{ f.name }}[i_]) < 0)
                goto oom;
        }
        if (mcpkg_mp_util_dbg_append(&s, &cap, &len, ",") < 0)
            goto oom;
    }

    {% elif f.kind == 'LIST_SCALAR' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=[%zu],",
                     p->{{ f.name }} ? mcpkg_stringlist_size(p->{{ f.name }}) : 0ul) < 0)
        goto oom;

    {% elif f.kind in ['LIST_STRUCT','LIST_BIN'] %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=[%zu],",
                     p->{{ f.name }} ? mcpkg_list_size(p->{{ f.name }}) : 0ul) < 0)
        goto oom;

    {% elif f.kind == 'STRUCT' %}
    if (mcpkg_mp_util_dbg_append(&s, &cap, &len, "{{ f.name }}=%s,",
                     p->{{ f.name }} ? "set" : "NULL") < 0)
        goto oom;

    {% endif %}
    {% endfor %}

    if (len > 0 && s[len - 1] == ',')
        s[len - 1] = '}';
    else
        (void)mcpkg_mp_util_dbg_append(&s, &cap, &len, "}");

    return s;
oom:
    free(s);
    return NULL;
}



MCPKG_API int {{ sym_prefix }}_pack(const struct {{ sch.c_struct }} *p,
                    void **out_buf, size_t *out_len)
{
    struct McPkgMpWriter w;
    int mpret;

    if (!p || !out_buf || !out_len)
        return MCPKG_MP_ERR_INVALID_ARG;

    mpret = mcpkg_mp_writer_init(&w);
    if (mpret != MCPKG_MP_NO_ERROR)
        return mpret;

    /* header(2) + all fields (pack nil for missing optionals) */
    mpret = mcpkg_mp_map_begin(&w, {{ 2 + sch.fields|length }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    mpret = mcpkg_mp_write_header(&w, "{{ sch.tag }}", {{ sch.version }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% for f in sch.fields %}
    /* {{ f.name }} */
    {% if f.kind == 'SCALAR' and f.type == 'str' %}
    if (p->{{ f.name }})
        mpret = mcpkg_mp_kv_str(&w, {{ f.key }}, p->{{ f.name }});
    else
        mpret = mcpkg_mp_kv_nil(&w, {{ f.key }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'SCALAR' and f.type == 'i32' %}
    mpret = mcpkg_mp_kv_i32(&w, {{ f.key }}, p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'SCALAR' and f.type == 'u32' %}
    mpret = mcpkg_mp_kv_u32(&w, {{ f.key }}, p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'SCALAR' and f.type == 'i64' %}
    mpret = mcpkg_mp_kv_i64(&w, {{ f.key }}, p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'SCALAR' and f.type == 'u64' %}
    /* encode u64 as i64 (non-negative) via util */
    mpret = mcpkg_mp_kv_i64(&w, {{ f.key }}, (int64_t)p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'BIN' %}
    mpret = mcpkg_mp_kv_bin(&w, {{ f.key }}, p->{{ f.name }}, {{ f.size }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'LIST_SCALAR' %}
    mpret = mcpkg_mp_kv_strlist(&w, {{ f.key }}, p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_w;

    {% elif f.kind == 'LIST_BIN' %}
    {
        size_t i_, n_ = p->{{ f.name }} ? mcpkg_list_size(p->{{ f.name }}) : 0;

        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, (uint32_t)n_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_w;

        for (i_ = 0; i_ < n_; i_++) {
            const void *elt_ = NULL;

            if (mcpkg_list_at(p->{{ f.name }}, i_, &elt_) != MCPKG_CONTAINER_OK || !elt_) {
                mpret = MCPKG_MP_ERR_PARSE;
                goto out_w;
            }
            mpret = mcpkg_mp_write_bin(&w, elt_, {{ f.size }});
            if (mpret != MCPKG_MP_NO_ERROR)
                goto out_w;
        }
    }

    {% elif f.kind == 'LIST_STRUCT' %}
    {
        size_t i_, n_ = p->{{ f.name }} ? mcpkg_list_size(p->{{ f.name }}) : 0;

        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, (uint32_t)n_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_w;

        for (i_ = 0; i_ < n_; i_++) {
            struct {{ f.ctype }} *elt_ = NULL;
            void *b_ = NULL;
            size_t bl_ = 0;

            if (mcpkg_list_at(p->{{ f.name }}, i_, &elt_) != MCPKG_CONTAINER_OK || !elt_) {
                mpret = MCPKG_MP_ERR_PARSE;
                goto out_w;
            }
            if (mcpkg_mp_{{ f.ref_sym }}_pack(elt_, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
                mpret = MCPKG_MP_ERR_PARSE;
                goto out_w;
            }
            mpret = mcpkg_mp_write_bin(&w, b_, (uint32_t)bl_);
            free(b_);
            if (mpret != MCPKG_MP_NO_ERROR)
                goto out_w;
        }
    }

    {% elif f.kind == 'STRUCT' %}
    if (p->{{ f.name }}) {
        void *b_ = NULL;
        size_t bl_ = 0;

        if (mcpkg_mp_{{ f.ref_sym }}_pack(p->{{ f.name }}, &b_, &bl_) != MCPKG_MP_NO_ERROR) {
            mpret = MCPKG_MP_ERR_PARSE;
            goto out_w;
        }
        mpret = mcpkg_mp_kv_bin(&w, {{ f.key }}, b_, (uint32_t)bl_);
        free(b_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_w;
    } else {
        mpret = mcpkg_mp_kv_nil(&w, {{ f.key }});
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_w;
    }

    {% endif %}
    {% endfor %}

    mpret = mcpkg_mp_writer_finish(&w, out_buf, out_len);
out_w:
    mcpkg_mp_writer_destroy(&w);
    return mpret;
}


MCPKG_API int {{ sym_prefix }}_unpack(const void *buf, size_t len,
                      struct {{ sch.c_struct }} **out_p)
{
    struct McPkgMpReader r;
    struct {{ sch.c_struct }} *p = NULL;
    int mpret, ver = 0;

    if (!buf || !len || !out_p)
        return MCPKG_MP_ERR_INVALID_ARG;

    mpret = mcpkg_mp_reader_init(&r, buf, len);
    if (mpret != MCPKG_MP_NO_ERROR)
        return mpret;

    mpret = mcpkg_mp_expect_tag(&r, "{{ sch.tag }}", &ver);
    if (mpret != MCPKG_MP_NO_ERROR)
        goto out_r;

    p = {{ sym_prefix }}_new();
    if (!p) {
        mpret = MCPKG_MP_ERR_NO_MEMORY;
        goto out_r;
    }

    {% for f in sch.fields %}
    /* {{ f.name }} */
    {% if f.kind == 'SCALAR' and f.type == 'str' %}
    {
        const char *ptr_ = NULL;
        size_t pl_ = 0;
        int found_ = 0;

        mpret = mcpkg_mp_get_str_borrow(&r, {{ f.key }}, &ptr_, &pl_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        if (found_ && ptr_) {
            p->{{ f.name }} = malloc(pl_ + 1);
            if (!p->{{ f.name }}) {
                mpret = MCPKG_MP_ERR_NO_MEMORY;
                goto out_err;
            }
            memcpy(p->{{ f.name }}, ptr_, pl_);
            p->{{ f.name }}[pl_] = '\0';
        }
        {% if f.required %} if (!found_ || !p->{{ f.name }}) { mpret = MCPKG_MP_ERR_PARSE; goto out_err; } {% endif %}
    }

    {% elif f.kind == 'SCALAR' and f.type in ['i32','u32'] %}
    {
        uint32_t val_ = 0;
        int found_ = 0;

        mpret = mcpkg_mp_get_u32(&r, {{ f.key }}, &val_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        if (found_)
            p->{{ f.name }} = (int32_t)val_;
        {% if f.required %} if (!found_) { mpret = MCPKG_MP_ERR_PARSE; goto out_err; } {% endif %}
    }

    {% elif f.kind == 'SCALAR' and f.type in ['i64','u64'] %}
    {
        uint64_t val_ = 0;
        int found_ = 0;

        mpret = mcpkg_mp_get_u64(&r, {{ f.key }}, &val_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        if (found_)
            p->{{ f.name }} = (int64_t)val_;
        {% if f.required %} if (!found_) { mpret = MCPKG_MP_ERR_PARSE; goto out_err; } {% endif %}
    }

    {% elif f.kind == 'BIN' %}
    {
        const void *ptr_ = NULL;
        size_t pl_ = 0;
        int found_ = 0;

        mpret = mcpkg_mp_get_bin_borrow(&r, {{ f.key }}, &ptr_, &pl_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        {% if f.required %}
        if (!found_ || pl_ != {{ f.size }}) {
            mpret = MCPKG_MP_ERR_PARSE;
            goto out_err;
        }
        {% else %}
        if (found_ && ptr_ && pl_ != {{ f.size }}) {
            mpret = MCPKG_MP_ERR_PARSE;
            goto out_err;
        }
        {% endif %}

        if (found_ && ptr_ && pl_ == {{ f.size }})
            memcpy(p->{{ f.name }}, ptr_, {{ f.size }});
    }

    {% elif f.kind == 'LIST_SCALAR' %}
    {
        struct McPkgStringList *sl_ = NULL;

        mpret = mcpkg_mp_get_strlist_dup(&r, {{ f.key }}, &sl_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        p->{{ f.name }} = sl_;
        {% if f.required %} if (!p->{{ f.name }}) { mpret = MCPKG_MP_ERR_PARSE; goto out_err; } {% endif %}
    }

    {% elif f.kind == 'LIST_BIN' %}
    {
        struct McPkgMpArrayCur *cur_ = NULL;
        size_t n_ = 0, i_;
        int found_ = 0;

        mpret = mcpkg_mp_get_array_cur(&r, {{ f.key }}, &cur_, &n_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        {% if f.required %}
        if (!found_) {
            mpret = MCPKG_MP_ERR_PARSE;
            mcpkg_mp_array_cur_destroy(cur_);
            goto out_err;
        }
        {% endif %}

        if (found_ && n_ > 0) {
            p->{{ f.name }} = mcpkg_list_new({{ f.size }}, NULL, 0, 0);
            if (!p->{{ f.name }}) {
                mpret = MCPKG_MP_ERR_NO_MEMORY;
                mcpkg_mp_array_cur_destroy(cur_);
                goto out_err;
            }
            for (i_ = 0; i_ < n_; i_++) {
                const void *ptr_ = NULL;
                size_t pl_ = 0;

                if (mcpkg_mp_array_get_bin_borrow(cur_, i_, &ptr_, &pl_) != MCPKG_MP_NO_ERROR) {
                    mcpkg_mp_array_cur_destroy(cur_);
                    goto out_err;
                }
                if (pl_ != {{ f.size }}) {
                    mcpkg_mp_array_cur_destroy(cur_);
                    mpret = MCPKG_MP_ERR_PARSE;
                    goto out_err;
                }
                if (mcpkg_list_push(p->{{ f.name }}, ptr_) != MCPKG_CONTAINER_OK) {
                    mcpkg_mp_array_cur_destroy(cur_);
                    mpret = MCPKG_MP_ERR_NO_MEMORY;
                    goto out_err;
                }
            }
        }

        if (cur_)
            mcpkg_mp_array_cur_destroy(cur_);
    }

    {% elif f.kind == 'LIST_STRUCT' %}
    {
        struct McPkgMpArrayCur *cur_ = NULL;
        size_t n_ = 0;
        size_t i_;
        int found_ = 0;

        mpret = mcpkg_mp_get_array_cur(&r, {{ f.key }}, &cur_, &n_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        {% if f.required %}
        if (!found_) {
            mpret = MCPKG_MP_ERR_PARSE;
            mcpkg_mp_array_cur_destroy(cur_);
            goto out_err;
        }
        {% endif %}

        if (found_ && n_ > 0) {
            /// yikes
            p->{{ f.name }} = mcpkg_list_new(sizeof(struct {{ f.ctype }}*), NULL, 0, 0);
            if (!p->{{ f.name }}) {
                mpret = MCPKG_MP_ERR_NO_MEMORY;
                mcpkg_mp_array_cur_destroy(cur_);
                goto out_err;
            }
            for (i_ = 0; i_ < n_; i_++) {
                const void *ptr_ = NULL;
                size_t pl_ = 0;
                struct {{ f.ctype }} *elt_ = NULL;

                if (mcpkg_mp_array_get_bin_borrow(cur_, i_, &ptr_, &pl_) != MCPKG_MP_NO_ERROR) {
                    mcpkg_mp_array_cur_destroy(cur_);
                    goto out_err;
                }
                if (mcpkg_mp_{{ f.ref_sym }}_unpack(ptr_, pl_, &elt_) != MCPKG_MP_NO_ERROR) {
                    mcpkg_mp_array_cur_destroy(cur_);
                    mpret = MCPKG_MP_ERR_PARSE;
                    goto out_err;
                }
                if (mcpkg_list_push(p->{{ f.name }}, &elt_) != MCPKG_CONTAINER_OK) {
                    mcpkg_mp_{{ f.ref_sym }}_free(elt_);
                    mcpkg_mp_array_cur_destroy(cur_);
                    mpret = MCPKG_MP_ERR_NO_MEMORY;
                    goto out_err;
                }
            }
        }

        if (cur_)
            mcpkg_mp_array_cur_destroy(cur_);
    }

    {% elif f.kind == 'STRUCT' %}
    {
        const void *ptr_ = NULL;
        size_t pl_ = 0;
        int found_ = 0;

        mpret = mcpkg_mp_get_bin_borrow(&r, {{ f.key }}, &ptr_, &pl_, &found_);
        if (mpret != MCPKG_MP_NO_ERROR)
            goto out_err;

        {% if f.required %}
        if (!found_ || !ptr_ || pl_ == 0) {
            mpret = MCPKG_MP_ERR_PARSE;
            goto out_err;
        }
        {% endif %}

        if (found_ && ptr_ && pl_ > 0) {
            if (mcpkg_mp_{{ f.ref_sym }}_unpack(ptr_, pl_, &p->{{ f.name }}) != MCPKG_MP_NO_ERROR) {
                mpret = MCPKG_MP_ERR_PARSE;
                goto out_err;
            }
        }
    }

    {% endif %}
    {% endfor %}

    *out_p = p;
    mcpkg_mp_reader_destroy(&r);
    return MCPKG_MP_NO_ERROR;

out_err:
    {{ sym_prefix }}_free(p);
out_r:
    mcpkg_mp_reader_destroy(&r);
    return mpret;
}
