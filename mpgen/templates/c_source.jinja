/* AUTOGENERATED by mpgen â€” do not edit.
 * Source schema: {{ schema.path }}
 */

#include "{{ include_prefix }}/mcpkg_mp_{{ out_base }}.h"
{% for inc in src_includes if inc != include_prefix ~ "/mcpkg_mp_" ~ out_base ~ ".h" -%}
#include "{{ inc }}"
{% endfor %}

#include <string.h>
#include <stdlib.h>

/* ---------- internal helpers ---------- */

static int
_validate_{{ out_base }}(const struct {{ c_struct }} *p)
{
    if (!p) return MCPKG_MP_ERR_INVALID_ARG;
    (void)p;

    {% for f in fields %}
    {% if f.required %}
    /* required: {{ f.name }} */
    {% if f.kind == 'scalar' and f.ftype == 'str' %}
    if (!p->{{ f.name }}) return MCPKG_MP_ERR_PARSE;
    {% elif f.kind == 'scalar' and f.ftype in ['i32','u32','i64'] %}
    /* integers: presence assumed */
    {% elif f.kind == 'scalar' and f.ftype == 'bin' %}
    /* fixed bin: always present as inline array */
    {% elif f.kind == 'list_str' %}
    if (!p->{{ f.name }}) return MCPKG_MP_ERR_PARSE;
    {% elif f.kind == 'struct_bin' %}
    if (!p->{{ f.name }}) return MCPKG_MP_ERR_PARSE;
    {% elif f.kind == 'list_struct_bin' %}
    if (!p->{{ f.name }}) return MCPKG_MP_ERR_PARSE;
    {% endif %}
    {% endif %}
    {% endfor %}

    return MCPKG_MP_NO_ERROR;
}

/* ---------- lifetime ---------- */

MCPKG_API struct {{ c_struct }} *
mcpkg_mp_{{ out_base }}_new(void)
{
    struct {{ c_struct }} *p =
        (struct {{ c_struct }} *)calloc(1, sizeof(*p));
    if (!p) return NULL;

    {% for f in fields %}
    {% if f.kind == 'scalar' and f.ftype == 'str' %}
    p->{{ f.name }} = NULL;
    {% elif f.kind == 'list_str' %}
    p->{{ f.name }} = NULL;
    {% elif f.kind == 'struct_bin' %}
    p->{{ f.name }} = NULL;
    {% elif f.kind == 'list_struct_bin' %}
    p->{{ f.name }} = NULL;
    {% elif f.kind == 'scalar' and f.ftype == 'bin' %}
    /* inline bin already zeroed by calloc */
    {% endif %}
    {% endfor %}

    return p;
}

MCPKG_API void
mcpkg_mp_{{ out_base }}_free(struct {{ c_struct }} *p)
{
    if (!p) return;

    {% for f in fields %}
    {% if f.kind == 'scalar' and f.ftype == 'str' %}
    free(p->{{ f.name }});
    {% elif f.kind == 'list_str' %}
    if (p->{{ f.name }}) mcpkg_stringlist_free(p->{{ f.name }});
    {% elif f.kind == 'struct_bin' %}
    if (p->{{ f.name }}) mcpkg_mp_{{ f.ref_unit }}_free(p->{{ f.name }});
    {% elif f.kind == 'list_struct_bin' %}
    if (p->{{ f.name }}) {
        size_t _n = mcpkg_list_size(p->{{ f.name }});
        for (size_t _i = 0; _i < _n; _i++) {
            struct {{ f.ref_struct }} *child = NULL;
            (void)mcpkg_list_at(p->{{ f.name }}, _i, &child);
            if (child) mcpkg_mp_{{ f.ref_unit }}_free(child);
        }
        mcpkg_list_free(p->{{ f.name }});
    }
    {% endif %}
    {% endfor %}

    free(p);
}

/* ---------- pack ---------- */

MCPKG_API int
mcpkg_mp_{{ out_base }}_pack(const struct {{ c_struct }} *p,
                             void **out_buf, size_t *out_len)
{
    int ret;
    struct McPkgMpWriter w;
    int mpret;

    if (!p || !out_buf || !out_len)
        return MCPKG_MP_ERR_INVALID_ARG;

    ret = _validate_{{ out_base }}(p);
    if (ret != MCPKG_MP_NO_ERROR)
        return ret;

    mpret = mcpkg_mp_writer_init(&w);
    if (mpret != MCPKG_MP_NO_ERROR)
        return mpret;

    /* count keys: TAG + VER + fields (nil included) */
    {
        uint32_t nkeys = 2 + (uint32_t)({{ fields|length }});
        mpret = mcpkg_mp_map_begin(&w, nkeys);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
    }

    /* header */
    mpret = mcpkg_mp_write_header(&w,
                                  MCPKG_MP_{{ macro_prefix_up }}_{{ macro_base_up }}_TAG,
                                  MCPKG_MP_{{ macro_prefix_up }}_{{ macro_base_up }}_VER);
    if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }

    /* fields */
    {% for f in fields %}
    /* key {{ f.key }}: {{ f.name }} ({{ f.kind }} {{ f|field_macro }}) */
    {% if f.kind == 'scalar' %}
        {% if f.ftype in ['i32','u32','i64'] %}
    mpret = mcpkg_mp_kv_{{ 'i32' if f.ftype == 'i32' else ('u32' if f.ftype == 'u32' else 'i64') }}(&w, {{ f.key }}, p->{{ f.name }});
    if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        {% elif f.ftype == 'str' %}
    if (p->{{ f.name }})
        mpret = mcpkg_mp_kv_str(&w, {{ f.key }}, p->{{ f.name }});
    else
        mpret = mcpkg_mp_kv_nil(&w, {{ f.key }});
    if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        {% elif f.ftype == 'bin' %}
    mpret = mcpkg_mp_kv_bin(&w, {{ f.key }}, p->{{ f.name }}, {{ f.size or 0 }});
    if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        {% endif %}
    {% elif f.kind == 'list_str' %}
    if (p->{{ f.name }}) {
        size_t _n = mcpkg_stringlist_size(p->{{ f.name }});
        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, (uint32_t)_n);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        for (size_t _i = 0; _i < _n; _i++) {
            const char *s = mcpkg_stringlist_at(p->{{ f.name }}, _i);
            if (!s) s = "";
            mpret = mcpkg_mp_write_str(&w, s);
            if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        }
    } else {
        /* nil list */
        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, 0);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
    }
    {% elif f.kind == 'struct_bin' %}
    if (p->{{ f.name }}) {
        void *cb = NULL; size_t cn = 0;
        int cr = mcpkg_mp_{{ f.ref_unit }}_pack(p->{{ f.name }}, &cb, &cn);
        if (cr != MCPKG_MP_NO_ERROR) { ret = cr; goto out_w; }
        mpret = mcpkg_mp_kv_bin(&w, {{ f.key }}, cb, (uint32_t)cn);
        free(cb);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
    } else {
        mpret = mcpkg_mp_kv_bin(&w, {{ f.key }}, NULL, 0);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
    }
    {% elif f.kind == 'list_struct_bin' %}
    if (p->{{ f.name }}) {
        size_t _n = mcpkg_list_size(p->{{ f.name }});
        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, (uint32_t)_n);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        for (size_t _i = 0; _i < _n; _i++) {
            struct {{ f.ref_struct }} *child = NULL;
            (void)mcpkg_list_at(p->{{ f.name }}, _i, &child);
            if (!child) {
                /* empty child -> write empty bin */
                mpret = mcpkg_mp_write_bin(&w, NULL, 0);
                if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
                continue;
            }
            void *cb = NULL; size_t cn = 0;
            int cr = mcpkg_mp_{{ f.ref_unit }}_pack(child, &cb, &cn);
            if (cr != MCPKG_MP_NO_ERROR) { ret = cr; goto out_w; }
            mpret = mcpkg_mp_write_bin(&w, cb, (uint32_t)cn);
            free(cb);
            if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
        }
    } else {
        mpret = mcpkg_mp_kv_array_begin(&w, {{ f.key }}, 0);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_w; }
    }
    {% endif %}
    {% endfor %}

    mpret = mcpkg_mp_writer_finish(&w, out_buf, out_len);
    ret = (mpret == MCPKG_MP_NO_ERROR) ? MCPKG_MP_NO_ERROR : mpret;

out_w:
    mcpkg_mp_writer_destroy(&w);
    return ret;
}

/* ---------- unpack ---------- */

MCPKG_API int
mcpkg_mp_{{ out_base }}_unpack(const void *buf, size_t len,
                               struct {{ c_struct }} *out)
{
    int ret = MCPKG_MP_NO_ERROR;
    struct McPkgMpReader r;
    int mpret, ver = 0, found = 0;

    if (!buf || !len || !out)
        return MCPKG_MP_ERR_INVALID_ARG;

    memset(out, 0, sizeof(*out));

    mpret = mcpkg_mp_reader_init(&r, buf, len);
    if (mpret != MCPKG_MP_NO_ERROR)
        return mpret;

    mpret = mcpkg_mp_expect_tag(&r,
                                MCPKG_MP_{{ macro_prefix_up }}_{{ macro_base_up }}_TAG,
                                &ver);
    if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_r; }
    (void)ver;

    {% for f in fields %}
    /* key {{ f.key }}: {{ f.name }} */
    {% if f.kind == 'scalar' %}
        {% if f.ftype in ['i32','u32','i64'] %}
    {
        int64_t i64 = 0;
        mpret = mcpkg_mp_get_i64(&r, {{ f.key }}, &i64, &found);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (found) {
            {% if f.ftype == 'i32' %} out->{{ f.name }} = (int32_t)i64;
            {% elif f.ftype == 'u32' %} out->{{ f.name }} = (uint32_t)i64;
            {% else %} out->{{ f.name }} = (int64_t)i64; {% endif %}
        } else {
            {% if f.required %} ret = MCPKG_MP_ERR_PARSE; goto out_fail; {% endif %}
        }
    }
        {% elif f.ftype == 'str' %}
    {
        const char *sp = NULL; size_t sn = 0;
        mpret = mcpkg_mp_get_str_borrow(&r, {{ f.key }}, &sp, &sn, &found);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (found && sp && sn) {
            out->{{ f.name }} = (char *)malloc(sn + 1);
            if (!out->{{ f.name }}) { ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
            memcpy(out->{{ f.name }}, sp, sn);
            out->{{ f.name }}[sn] = '\0';
        } else if ({{ 1 if f.required else 0 }}) {
            ret = MCPKG_MP_ERR_PARSE; goto out_fail;
        }
    }
        {% elif f.ftype == 'bin' %}
    {
        const void *bp = NULL; size_t bn = 0;
        mpret = mcpkg_mp_get_bin_borrow(&r, {{ f.key }}, &bp, &bn, &found);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (found) {
            {% if f.size %}
            if (bn != {{ f.size }}) { ret = MCPKG_MP_ERR_PARSE; goto out_fail; }
            memcpy(out->{{ f.name }}, bp, bn);
            {% else %}
            /* variable-length bin: ignored here (no dest buffer) */
            {% endif %}
        } else {
            {% if f.required %} ret = MCPKG_MP_ERR_PARSE; goto out_fail; {% endif %}
        }
    }
        {% endif %}
    {% elif f.kind == 'list_str' %}
    {
        void *cur = NULL; size_t n = 0;
        mpret = mcpkg_mp_get_array_cur(&r, {{ f.key }}, &cur, &n);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (cur) {
            McPkgStringList *sl = mcpkg_stringlist_new(0,0);
            if (!sl) { mcpkg_mp_array_cur_destroy(cur); ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
            for (size_t i = 0; i < n; i++) {
                const char *sp = NULL; size_t sn = 0; int ok = 0;
                mpret = mcpkg_mp_array_get_str_borrow(cur, i, &sp, &sn, &ok);
                if (mpret != MCPKG_MP_NO_ERROR) { mcpkg_mp_array_cur_destroy(cur); ret = mpret; goto out_fail; }
                if (ok && sp) {
                    char *dup = (char *)malloc(sn + 1);
                    if (!dup) { mcpkg_mp_array_cur_destroy(cur); ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
                    memcpy(dup, sp, sn); dup[sn] = '\0';
                    if (mcpkg_stringlist_push(sl, dup) != MCPKG_CONTAINER_OK) {
                        free(dup); mcpkg_mp_array_cur_destroy(cur);
                        ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail;
                    }
                    free(dup);
                } else {
                    /* treat nil as empty string for robustness */
                    if (mcpkg_stringlist_push(sl, "") != MCPKG_CONTAINER_OK) {
                        mcpkg_mp_array_cur_destroy(cur);
                        ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail;
                    }
                }
            }
            out->{{ f.name }} = sl;
            mcpkg_mp_array_cur_destroy(cur);
        } else if ({{ 1 if f.required else 0 }}) {
            ret = MCPKG_MP_ERR_PARSE; goto out_fail;
        }
    }
    {% elif f.kind == 'struct_bin' %}
    {
        const void *bp = NULL; size_t bn = 0;
        mpret = mcpkg_mp_get_bin_borrow(&r, {{ f.key }}, &bp, &bn, &found);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (found && bp && bn) {
            out->{{ f.name }} = mcpkg_mp_{{ f.ref_unit }}_new();
            if (!out->{{ f.name }}) { ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
            {
                int cr = mcpkg_mp_{{ f.ref_unit }}_unpack(bp, bn, out->{{ f.name }});
                if (cr != MCPKG_MP_NO_ERROR) { ret = cr; goto out_fail; }
            }
        } else if ({{ 1 if f.required else 0 }}) {
            ret = MCPKG_MP_ERR_PARSE; goto out_fail;
        }
    }
    {% elif f.kind == 'list_struct_bin' %}
    {
        void *cur = NULL; size_t n = 0;
        mpret = mcpkg_mp_get_array_cur(&r, {{ f.key }}, &cur, &n);
        if (mpret != MCPKG_MP_NO_ERROR) { ret = mpret; goto out_fail; }
        if (cur) {
            McPkgList *lst = mcpkg_list_new(sizeof(struct {{ f.ref_struct }} *), NULL, 0, 0);
            if (!lst) { mcpkg_mp_array_cur_destroy(cur); ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
            for (size_t i = 0; i < n; i++) {
                const void *bp = NULL; size_t bn = 0; int ok = 0;
                mpret = mcpkg_mp_array_get_bin_borrow(cur, i, &bp, &bn, &ok);
                if (mpret != MCPKG_MP_NO_ERROR) { mcpkg_mp_array_cur_destroy(cur); ret = mpret; goto out_fail; }
                if (!ok || !bp || !bn) {
                    /* push NULL placeholder */
                    struct {{ f.ref_struct }} *nilp = NULL;
                    if (mcpkg_list_push(lst, &nilp) != MCPKG_CONTAINER_OK) {
                        mcpkg_mp_array_cur_destroy(cur); ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail;
                    }
                } else {
                    struct {{ f.ref_struct }} *child = mcpkg_mp_{{ f.ref_unit }}_new();
                    if (!child) { mcpkg_mp_array_cur_destroy(cur); ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail; }
                    int cr = mcpkg_mp_{{ f.ref_unit }}_unpack(bp, bn, child);
                    if (cr != MCPKG_MP_NO_ERROR) {
                        mcpkg_mp_array_cur_destroy(cur);
                        mcpkg_mp_{{ f.ref_unit }}_free(child);
                        ret = cr; goto out_fail;
                    }
                    if (mcpkg_list_push(lst, &child) != MCPKG_CONTAINER_OK) {
                        mcpkg_mp_array_cur_destroy(cur);
                        mcpkg_mp_{{ f.ref_unit }}_free(child);
                        ret = MCPKG_MP_ERR_NO_MEMORY; goto out_fail;
                    }
                }
            }
            out->{{ f.name }} = lst;
            mcpkg_mp_array_cur_destroy(cur);
        } else if ({{ 1 if f.required else 0 }}) {
            ret = MCPKG_MP_ERR_PARSE; goto out_fail;
        }
    }
    {% endif %}
    {% endfor %}

    mcpkg_mp_reader_destroy(&r);
    return MCPKG_MP_NO_ERROR;

out_fail:
    mcpkg_mp_reader_destroy(&r);
    mcpkg_mp_{{ out_base }}_free(out);
    return ret;

out_r:
    mcpkg_mp_reader_destroy(&r);
    return ret;
}

/* ---------- debug string ---------- */

struct _dsb { char *p; size_t n, cap; };

static void _ds_init(struct _dsb *d){ d->p=NULL; d->n=0; d->cap=0; }
static int _ds_grow(struct _dsb *d, size_t need){
    if (d->n + need + 1 <= d->cap) return 1;
    size_t nc = d->cap ? d->cap*2 : 64;
    while (nc < d->n + need + 1) nc*=2;
    char *np = (char*)realloc(d->p, nc);
    if (!np) return 0;
    d->p = np; d->cap = nc; return 1;
}
static void _ds_append(struct _dsb *d, const char *s){
    size_t m = s ? strlen(s) : 6;
    if (!_ds_grow(d, m)) return;
    memcpy(d->p + d->n, s ? s : "(null)", m);
    d->n += m; d->p[d->n] = '\0';
}
static void _ds_appendf(struct _dsb *d, const char *fmt, ...){
    va_list ap; va_start(ap, fmt);
    for(;;){
        size_t avail = (d->cap > d->n)? (d->cap - d->n) : 0;
        if (avail < 16) { if(!_ds_grow(d, 64)) break; avail = d->cap - d->n; }
        int w = vsnprintf(d->p + d->n, avail, fmt, ap);
        if (w < 0) break;
        if ((size_t)w < avail) { d->n += (size_t)w; break; }
        if(!_ds_grow(d, (size_t)w+1)) break;
    }
    va_end(ap);
}
static char *_ds_take(struct _dsb *d){ return d->p; }

MCPKG_API char *
mcpkg_mp_{{ out_base }}_debug_str(const struct {{ c_struct }} *p)
{
    struct _dsb d; _ds_init(&d);
    _ds_appendf(&d, "{{ c_struct }}{ ");

    {% set first = True %}
    {% for f in fields %}
    {% if not first %}_ds_append(&d, ", ");{% endif %}
    {% set first = False %}

    _ds_appendf(&d, "{{ f.name }}=");
    {% if f.kind == 'scalar' and f.ftype in ['i32','u32','i64'] %}
    _ds_appendf(&d, "%lld", (long long)p->{{ f.name }});
    {% elif f.kind == 'scalar' and f.ftype == 'str' %}
    _ds_appendf(&d, "\"%s\"", p->{{ f.name }} ? p->{{ f.name }} : "(null)");
    {% elif f.kind == 'scalar' and f.ftype == 'bin' %}
    {
        _ds_append(&d, "0x");
        for (size_t i=0;i<{{ f.size or 0 }};i++) _ds_appendf(&d, "%02x", p->{{ f.name }}[i]);
    }
    {% elif f.kind == 'list_str' %}
    if (p->{{ f.name }}) {
        size_t _n = mcpkg_stringlist_size(p->{{ f.name }});
        _ds_append(&d, "[");
        for (size_t _i=0; _i<_n; _i++) {
            const char *s = mcpkg_stringlist_at(p->{{ f.name }}, _i);
            _ds_appendf(&d, "\"%s\"%s", s ? s : "", (_i+1<_n) ? "," : "");
        }
        _ds_append(&d, "]");
    } else {
        _ds_append(&d, "[]");
    }
    {% elif f.kind == 'struct_bin' %}
    if (p->{{ f.name }}) {
        char *cs = mcpkg_mp_{{ f.ref_unit }}_debug_str(p->{{ f.name }});
        if (cs) { _ds_append(&d, cs); free(cs); }
        else _ds_append(&d, "(null)");
    } else {
        _ds_append(&d, "null");
    }
    {% elif f.kind == 'list_struct_bin' %}
    if (p->{{ f.name }}) {
        size_t _n = mcpkg_list_size(p->{{ f.name }});
        _ds_append(&d, "[");
        for (size_t _i=0; _i<_n; _i++) {
            struct {{ f.ref_struct }} *child=NULL;
            (void)mcpkg_list_at(p->{{ f.name }}, _i, &child);
            if (child) {
                char *cs = mcpkg_mp_{{ f.ref_unit }}_debug_str(child);
                if (cs) { _ds_append(&d, cs); free(cs); }
                else _ds_append(&d, "(null)");
            } else {
                _ds_append(&d, "null");
            }
            if (_i+1<_n) _ds_append(&d, ",");
        }
        _ds_append(&d, "]");
    } else {
        _ds_append(&d, "[]");
    }
    {% endif %}
    {% endfor %}

    _ds_append(&d, " }");
    return _ds_take(&d);
}
