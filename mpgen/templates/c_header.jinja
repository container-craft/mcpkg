/* SPDX-License-Identifier: MIT */
/*
 * AUTOGENERATED by mpgen â€” DO NOT EDIT BY HAND.
 * Source schema: {{ sch.schema_path if sch.schema_path is defined else (sch.unit ~ "/" ~ sch.base) }}
 */

#ifndef MCPKG_MP_{{ header_guard(sch.include_prefix, sch.out_base) }}_H
#define MCPKG_MP_{{ header_guard(sch.include_prefix, sch.out_base) }}_H

#include <stddef.h>
#include <stdint.h>

#include "mcpkg_export.h"

{% set need_strlist  = (sch.fields | selectattr('kind','equalto','LIST_SCALAR') | list | length) > 0 %}
{% set need_list_any = (sch.fields | selectattr('kind','equalto','LIST_STRUCT') | list | length) > 0
                        or (sch.fields | selectattr('kind','equalto','LIST_BIN') | list | length) > 0 %}
{% if need_strlist %}
#include "container/mcpkg_str_list.h"
{% endif %}
{% if need_list_any %}
#include "container/mcpkg_list.h"
{% endif %}

MCPKG_BEGIN_DECLS

#define MCPKG_MP_{{ header_guard(sch.include_prefix, sch.out_base) }}_TAG "{{ sch.tag }}"
#define MCPKG_MP_{{ header_guard(sch.include_prefix, sch.out_base) }}_VER {{ sch.version }}

{% for f in sch.fields if f.kind in ['STRUCT','LIST_STRUCT'] -%}
struct {{ f.ctype }};
{% endfor %}

struct {{ sch.c_struct }} {
{% for f in sch.fields -%}
{% if f.kind == 'SCALAR' -%}
{% if f.type == 'str' -%}
    char			*{{ f.name }};
{% elif f.type == 'i32' -%}
    int32_t			{{ f.name }};
{% elif f.type == 'u32' -%}
    uint32_t		{{ f.name }};
{% elif f.type == 'i64' -%}
    int64_t			{{ f.name }};
{% elif f.type == 'u64' -%}
    uint64_t		{{ f.name }};
{% endif -%}
{% elif f.kind == 'BIN' -%}
    uint8_t			{{ f.name }}[{{ f.size }}];
{% elif f.kind == 'LIST_SCALAR' -%}
    struct McPkgStringList	*{{ f.name }};
{% elif f.kind == 'LIST_BIN' -%}
    /* list of fixed-size byte arrays ({{ f.size }} bytes each) */
    struct McPkgList	*{{ f.name }};
{% elif f.kind == 'LIST_STRUCT' -%}
    /* list of struct {{ f.ctype }} * */
    struct McPkgList	*{{ f.name }};
{% elif f.kind == 'STRUCT' -%}
    struct {{ f.ctype }}	*{{ f.name }};
{% endif -%}
{% endfor -%}
};

MCPKG_API struct {{ sch.c_struct }} *mcpkg_mp_{{ sch.out_base }}_new(void);
MCPKG_API void mcpkg_mp_{{ sch.out_base }}_free(struct {{ sch.c_struct }} *p);

MCPKG_API int mcpkg_mp_{{ sch.out_base }}_pack(const struct {{ sch.c_struct }} *p,
                           void **out_buf, size_t *out_len);

MCPKG_API int mcpkg_mp_{{ sch.out_base }}_unpack(const void *buf, size_t len,
                         struct {{ sch.c_struct }} **out_p);

MCPKG_API char *mcpkg_mp_{{ sch.out_base }}_debug_str(const struct {{ sch.c_struct }} *p);

MCPKG_END_DECLS

#endif	/* MCPKG_MP_{{ header_guard(sch.include_prefix, sch.out_base) }}_H */
